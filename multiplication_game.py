"""
Логика игры для тренажера таблицы умножения
Данный модуль содержит класс MultiplicationGame, который управляет всей логикой игры:
- генерация вопросов на умножение
- проверка ответов пользователя
- подсчет статистики и очков
- управление временем игры
"""
import random  # Для генерации случайных чисел
from datetime import datetime  # Для отслеживания времени начала игры


class MultiplicationGame:
    """
    Основной класс игры. Отвечает за:
    - хранение текущего состояния игры (очки, статистика)
    - генерацию новых вопросов в зависимости от уровня сложности
    - проверку правильности ответов пользователя
    - подсчет времени игры
    """

    def __init__(self):
        """
        Инициализация нового экземпляра игры.
        Устанавливает начальные значения всех переменных.
        """
        self.score = 0  # Текущее количество очков
        self.correct_answers = 0  # Количество правильных ответов
        self.wrong_answers = 0  # Количество неправильных ответов
        self.current_question = None  # Текущий активный вопрос (словарь с данными)
        self.start_time = None  # Время начала текущей игры
        self.questions_answered = 0  # Общее количество отвеченных вопросов

        # Настройки уровней сложности.
        # Каждый уровень определяет диапазон чисел и лимит времени (хотя время не используется активно)
        self.levels = {
            "легкий": {"min": 1, "max": 5, "time_limit": 30},      # Простые примеры: числа 1-5
            "средний": {"min": 1, "max": 10, "time_limit": 25},    # Средние примеры: числа 1-10
            "сложный": {"min": 5, "max": 15, "time_limit": 20}     # Сложные примеры: числа 5-15
        }

        self.current_level = "средний"  # Текущий уровень сложности по умолчанию

    def start_new_game(self, level="средний"):
        """
        Начинает новую игру с заданным уровнем сложности.
        Сбрасывает всю статистику и генерирует первый вопрос.

        Аргументы:
            level (str): уровень сложности ("легкий", "средний", "сложный")
        """
        # Сброс всех показателей игры к начальным значениям
        self.score = 0
        self.correct_answers = 0
        self.wrong_answers = 0
        self.questions_answered = 0

        self.current_level = level  # Установка выбранного уровня сложности
        self.start_time = datetime.now()  # Запись времени начала игры
        self.generate_question()  # Генерация первого вопроса

    def generate_question(self):
        """
        Генерирует новый вопрос на умножение на основе текущего уровня сложности.
        Возвращает словарь с данными вопроса.

        Возвращает:
            dict: словарь с полями:
                - "text": текст вопроса в формате "a × b = ?"
                - "answer": правильный ответ (a * b)
                - "a": первое число
                - "b": второе число
        """
        # Получение настроек для текущего уровня сложности
        level_settings = self.levels[self.current_level]

        # Генерация двух случайных чисел в заданном диапазоне
        a = random.randint(level_settings["min"], level_settings["max"])
        b = random.randint(level_settings["min"], level_settings["max"])

        # Создание объекта вопроса с текстом и правильным ответом
        self.current_question = {
            "text": f"{a} × {b} = ?",  # Текст вопроса для отображения
            "answer": a * b,            # Правильный ответ
            "a": a,                     # Первое число (для подсказок)
            "b": b                      # Второе число (для подсказок)
        }

        return self.current_question  # Возврат созданного вопроса

    def check_answer(self, user_answer):
        """
        Проверяет ответ пользователя на текущий вопрос.
        Обновляет статистику и начисляет очки.

        Аргументы:
            user_answer (str или int): ответ, введенный пользователем

        Возвращает:
            tuple: (is_correct, points) где:
                - is_correct (bool): True если ответ правильный, иначе False
                - points (int): количество начисленных очков
        """
        # Преобразование ответа пользователя в целое число
        try:
            user_answer = int(user_answer)
        except ValueError:
            # Если преобразование не удалось (пользователь ввел не число)
            return False, 0  # Ответ неправильный, 0 очков

        # Проверка совпадения ответа пользователя с правильным ответом
        is_correct = user_answer == self.current_question["answer"]
        self.questions_answered += 1  # Увеличение счетчика отвеченных вопросов

        if is_correct:
            # Если ответ правильный
            self.correct_answers += 1  # Увеличение счетчика правильных ответов

            # Начисление очков в зависимости от уровня сложности
            if self.current_level == "легкий":
                points = 5      # 5 очков за правильный ответ на легком уровне
            elif self.current_level == "средний":
                points = 10     # 10 очков за правильный ответ на среднем уровне
            else:  # сложный
                points = 15     # 15 очков за правильный ответ на сложном уровне

            self.score += points  # Добавление очков к общему счету
        else:
            # Если ответ неправильный
            self.wrong_answers += 1  # Увеличение счетчика неправильных ответов
            points = 0  # За неправильный ответ очки не начисляются

        # Возврат результата проверки и количества начисленных очков
        return is_correct, points

    def get_stats(self):
        """
        Собирает и возвращает текущую статистику игры.

        Возвращает:
            dict: словарь с текущей статистикой:
                - "score": общее количество очков
                - "correct": количество правильных ответов
                - "wrong": количество неправильных ответов
                - "accuracy": процент правильных ответов (округляется до 1 знака)
                - "total_questions": общее количество отвеченных вопросов
        """
        # Расчет точности (процента правильных ответов)
        accuracy = 0
        if self.questions_answered > 0:
            # Точность = (правильные ответы / все ответы) * 100%
            accuracy = (self.correct_answers / self.questions_answered) * 100

        # Возврат статистики в виде словаря
        return {
            "score": self.score,
            "correct": self.correct_answers,
            "wrong": self.wrong_answers,
            "accuracy": round(accuracy, 1),  # Округление до одного знака после запятой
            "total_questions": self.questions_answered
        }

    def get_time_elapsed(self):
        """
        Вычисляет, сколько секунд прошло с начала текущей игры.

        Возвращает:
            int: количество секунд, прошедших с начала игры
            Если игра не начата, возвращает 0
        """
        if self.start_time:
            # Вычисление разницы между текущим временем и временем начала игры
            elapsed = datetime.now() - self.start_time
            return int(elapsed.total_seconds())  # Преобразование в целые секунды
        return 0  # Игра еще не начата